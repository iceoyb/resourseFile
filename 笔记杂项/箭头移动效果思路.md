箭头移动效果思路:

生成两个同样箭头盒子,一起向右移动

![image-20201215170406960](C:\Users\simon\AppData\Roaming\Typora\typora-user-images\image-20201215170406960.png)

以盒子宽度为位移单位做向右移动.



代码实现:

js代码(只有向右箭头实现了,其它方向预留了入口,具体实现代码未开发)

```java
/*react函数组件*/
const FlowArrow = (props) => {
  // 获取传入宽度
  const { width = 150, status = 0, direction = 'right', style, className } = props
  // 已知大小箭头尺寸为5*10 11*18 
  let smallArrowLength = 5, bigArrowLength = 11, smallArrowHeight = 10, bigArrowHeight = 18, arrowMargin = 0
  // 计算大小箭头数量
  /*
    --将宽度三等分后对箭头长度取模数计算出箭头数量
  */
  let smallArrowNum = Math.floor(width / 3 / (5 + 2 * arrowMargin))
  let bigArrowNum = Math.floor(width / 3 / 11)
  let arrowNum = 2 * smallArrowNum + bigArrowNum
  // 计算盒子宽高
  /*
    --使用箭头数量计算出合理宽度
  */
  let calcWidth, calcHeight

  calcWidth = smallArrowNum * (5 + arrowMargin * 2) * 2 + bigArrowNum * 11
  calcHeight = bigArrowNum > 0 ? bigArrowHeight : smallArrowHeight
  // 循环数组
  // 循环交替数组样式实现无缝轮播
  // className={styles[`arrow${i}`]}
  let arr = []
  for (let i = 0; i < arrowNum; i++) {
    if (i < smallArrowNum) {
      arr.push(<img key={i} src={right_dns} style={{ margin: `0 ${arrowMargin}px` }} />)
    } else if (i < smallArrowNum + bigArrowNum) {
      arr.push(<img key={i} src={right_2} />)
    } else {
      arr.push(<img key={i} src={right_dns} style={{ margin: `0 ${arrowMargin}px` }} />)
    }
  }

  return direction === 'left' || direction === 'right' ? (
    <div style={{ width, height: calcHeight, left: width * -1 }} className={styles.arrowContainer} >
      <div style={{ ...style, width: calcWidth, height: calcHeight }} className={`${styles.arrowShowArea} ${className}`} >
        <div className={styles.arrowZone1}>
          {arr.map(item => item)}
        </div>
        <div className={styles.arrowZone2} >
          {arr.map(item => item)}
        </div>
      </div>
    </div>
  ) : (
      <div width={calcHeight} style={{ backgroundColor: "blue" }} >
      </div>
    )
}

```

样式代码:

```
/*less样式*/
.arrowContainer {
  position: absolute;
  top: 57px;
  display: flex;
  justify-content: center;

  .arrowShowArea {
    position: absolute;
    overflow: hidden;

    @keyframes arrowAnimate {
      0% {
        transform: translateX(0);
      }

      100% {
        transform: translateX(100%);
      }
    }

    .arrowZone1 {
      position: absolute;
      // background-color: red;
      width: 100%;
      height: 100%;
      top: -5px;
      left: -100%;
      animation: arrowAnimate 1s linear infinite;

    }

    .arrowZone2 {
      position: absolute;
      // background-color: yellowgreen;
      width: 100%;
      height: 100%;
      top: -5px;
      left: 0%;
      animation: arrowAnimate 1s linear infinite;
    }
  }
}
```

