### 设计模式学习

地址:https://juejin.cn/book/6844733790204461070/

##### 工厂模式：

* 概念：具体工厂、概念工厂、开放封闭原则、

* 个人总结：工厂模式感觉就是通过概念工厂去构建规则，工厂模式核心是开放封闭，是指工厂是可拓展但不可变的。这个工厂模式的规则是用于实例化一个个简单工厂（工厂实例）需要参考的。

* 设计小册总结：

  大家现在回头对比一下抽象工厂和简单工厂的思路，思考一下：它们之间有哪些异同？

  它们的共同点，在于都**尝试去分离一个系统中变与不变的部分**。它们的不同在于**场景的复杂度**。在简单工厂的使用场景里，处理的对象是类，并且是一些非常好对付的类——它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性。抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对**共性**作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分，于是有了这样的四个关键角色：

  - **抽象工厂（抽象类，它不能被用于生成具体实例）：** 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。
  - **具体工厂（用于生成产品族里的一个具体的产品）：** 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。
  - **抽象产品（抽象类，它不能被用于生成具体实例）：** 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。
  - **具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）：** 比如我们上文中具体的一种操作系统、或具体的一种硬件等。

  抽象工厂模式的定义，是**围绕一个超级工厂创建其他工厂**。本节内容对一些工作年限不多的同学来说可能不太友好，但抽象工厂目前来说在JS世界里也应用得并不广泛，所以大家不必拘泥于细节，只需留意以下三点：

  1. 学会用 ES6 模拟 JAVA 中的抽象类；
  2. 了解抽象工厂模式中四个角色的定位与作用；
  3. 对“开放封闭原则”形成自己的理解，知道它好在哪，知道执行它的必要性。

  如果能对这三点有所掌握，那么这一节的目的就达到了，最难搞、最难受的抽象工厂也就告一段落了。

##### 单例模式：

* 保证一个类仅有一个实例，并提供一个访问它的全局访问点
* 特点：**不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例**
* 单例模式核心就是要保证一个类只有一个实例，已知两种实现版本。
  * 1-静态方法版 
  * 2-闭包版

##### 原型模式：

* 原型模式就是我们目前使用的原型范式，就是通过原型的实例化实现对原型的方法和属性的继承。

* 在原型模式下，当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过**克隆原型**的方式来创建出一个与原型一样（共享一套数据/方法）的对象。在 JavaScript 里，`Object.create`方法就是原型模式的天然实现——准确地说，只要我们还在借助`Prototype`来实现对象的创建和原型的继承，那么我们就是在应用原型模式。

* 案例：递归实现深拷贝

  ``` javascript
  function deepClone(obj) {
      // 如果是 值类型 或 null，则直接return
      if(typeof obj !== 'object' || obj === null) {
          return obj
      }
      
      // 定义结果对象
      let copy = {}
      
      // 如果对象是数组，则定义结果数组
      if(obj.constructor === Array) {
          copy = []
      }
      
      // 遍历对象的key
      for(let key in obj) {
          // 如果key是对象的自有属性
          if(obj.hasOwnProperty(key)) {
              // 递归调用深拷贝方法
              copy[key] = deepClone(obj[key])
          }
      }
      
      return copy
  } 
  ```

  

##### 装饰器模式

* 传入一个实例，在实例的基础上拓展新的功能。

* 单一责任原则：将职责分离，使得每个职责都可以被灵活地复用。同时，不同职责之间无法相互干扰

* 作用1：函数传参&调用

  ``` txt
  额外知识：
  数据描述符：
  	1.value	2.writable 3.enumerable 4.configurable
  存取描述符：
  	1.get 2.set
  ```

* 生产实践：

  react中的HOC--高阶组件

  **优质的源码阅读材料——core-decorators**

  前面都在教大家怎么写装饰器模式，这里来聊聊怎么**用好**装饰器模式。

  装饰器模式的优势在于其极强的灵活性和可复用性——它本质上是一个函数，而且往往不依赖于任何逻辑而存在。这一点提醒了我们，当我们需要用到某个反复出现的拓展逻辑时，比起自己闷头搞，不如去看一看团队（社区）里有没有现成的实现，如果有，那么贯彻“拿来主义”，直接@就可以了。所以说装饰器模式是个好同志，它可以帮我们省掉大量复制粘贴的时间。

  这里就要给大家推荐一个非常赞的装饰模式库 —— [core-decorators](https://github.com/jayphelps/core-decorators)。core-decorators 帮我们实现好了一些使用频率较高的装饰器，比如`@readonly`(使目标属性只读)、`@deprecate`(在控制台输出警告，提示用户某个指定的方法已被废除)等等等等。这里强烈建议大家把 core-decorators 作为自己的源码阅读材料，你能收获的或许比你想象中更多~

* 总结：

  种类有两种：

  1-类装饰器 ：一个参数，跟高阶组件基本是同一个东西

  2.方法装饰器：三个参数，装饰对象的原型--在原型去拓展对象的功能

##### 适配器模式

* 场景：适配器模式通过**把一个类的接口变换成客户端所期待的另一种接口**，可以帮我们解决**不兼容**的问题。--抹平差异
* 同样的入参和同样的出参，只拓展应用场景

##### 代理模式

* 核心：在A->B的过程中**拦截**，不允许A直接访问B。
* 类型：（场景）
  * 事件代理--利用事件冒泡，把事件的触发委托给父节点的相同事件上
  * 虚拟代理--案例--通过代理类（对象），实现图片的预加载。这个代理不出现在渲染层，所以叫虚拟代理
  * 缓存代理--案例--通过代理类（对象），实现结果（数据）的缓存。
  * 保护代理--案例--鉴权

##### 策略模式（理解不好--后续再看）

* 概念：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
* 过程：单一功能改造&&封闭开放改造

##### 状态模式（理解不好--后续再看）

* 定义 ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
* 过程：单一功能改造&&封闭开放改造
* 与策略模式区别：状态模式允许对象在改变时感知对象内部的状态。函数独立性要低得多

##### 观察者模式
* 概念：
  * 观察者模式定义了一种一对多的关系，让多个观察者同时监听一个目标对象，当目标对象的状态发生变化的时候，会通知所有的观察者，使他们能够自动更新。
* 方式：
  * 实现一个发布者
  * 实现一个订阅者
* 观察者模式和发布-订阅模式的区别：是否完全解耦，发布者能否直接感知订阅者
* 案例：
  * 1.MVVM实现
  * 2.实现一个Event Bus/ Event Emitter

##### 迭代器模式

* 目的：遍历
* 